#pragma once

#include <pthread.h>
#include "slCThreadImplBase.hp"

LE_NAMESPACE_START

class CThreadImplPosix : public CThreadImplBase
{
	public:
		inline CThreadImplPosix(const TCFunction<>& threadProc,
								const CString& threadName) :
			CThreadImplBase(threadProc, threadName)
		{
			mRegisteredThreads.push_back(this);
		}

		inline CThreadImplPosix(pthread_t id) :
			mThreadID(id)
		{

		}

		~CThreadImplPosix()
		{
			for (std::list<CThreadImplPosix*>::iterator it = mRegisteredThreads.begin(); it != mRegisteredThreads.end(); ++it)
			{
				if (*it == this)
				{
					mRegisteredThreads.erase(it);
					return;
				}
			}
		}

		virtual void start();

		static CThreadImplBase* thread();

	protected:
		pthread_t mThreadID;

	private:
		static std::list<CThreadImplPosix*> mRegisteredThreads;
};


typedef CThreadImplPosix CThreadImpl;
typedef pthread_t TThreadID;

LE_NAMESPACE_END
