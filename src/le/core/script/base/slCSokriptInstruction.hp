#if !defined SL_LE_core_script_base_slCSokriptInstruction_hp
#define SL_LE_core_script_base_slCSokriptInstruction_hp

#include <iosfwd>
#include <list>
#include <le/core/slTypes.h>
#include <le/core/slCObject.h>

#define _LE_FOR_INSTRUCTION_LIST(_OP_)	\
	_OP_(eInstructionPushVar)			\
	_OP_(eInstructionPushStr)			\
	_OP_(eInstructionPushInt)			\
	_OP_(eInstructionPushFloat)			\
	_OP_(eInstructionPushExternal)		\
	_OP_(eInstructionPushGlobalObject)	\
	_OP_(eInstructionDiscard)			\
	_OP_(eInstructionDuplicate)			\
	_OP_(eInstructionAssign)			\
	_OP_(eInstructionGetProperty)		\
	_OP_(eInstructionSetProperty)		\
	_OP_(eInstructionAdd)				\
	_OP_(eInstructionSubstract)			\
	_OP_(eInstructionMultiply)			\
	_OP_(eInstructionDivide)			\
	_OP_(eInstructionNegate)			\
	_OP_(eInstructionEqual)				\
	_OP_(eInstructionNotEqual)			\
	_OP_(eInstructionGreaterThan)		\
	_OP_(eInstructionGreaterEqual)		\
	_OP_(eInstructionLessThan)			\
	_OP_(eInstructionLessEqual)			\
	_OP_(eInstructionNot)				\
	_OP_(eInstructionSetSymbolsCount)	\
	_OP_(eInstructionJump)				\
	_OP_(eInstructionJumpIfTrue)		\
	_OP_(eInstructionDeclareExternalSymbol)		\
	_OP_(eInstructionDeclareSymbol)		\
	_OP_(eInstructionPushFunction)		\
	_OP_(eInstructionCall)				\
	_OP_(eInstructionReturn)

#define _LE_DECLARE_INSTRUCTION(instruction) instruction,

namespace sokira
{
	namespace le
	{

enum EInstruction
{
	eInstructionNOP = 0,
	_LE_FOR_INSTRUCTION_LIST(_LE_DECLARE_INSTRUCTION)
	eInstructionCount_			// This is not an instruction, just a constant indicating total instruction count
};


class CSokriptInstruction : public CObject
{
	LE_RTTI_BEGIN
		LE_RTTI_SELF(CSokriptInstruction)
		LE_RTTI_SINGLE_PUBLIC_PARENT
	LE_RTTI_END

	public:
		CSokriptInstruction() { LE_ASSERT(false); }

//		CSokriptInstruction(EInstruction instruction, CObject* arg1 = NULL) :
//			mInstruction(instruction),
//			mProcessed(false)
//		{
//			mObjArg1 = arg1;
//		}

		CSokriptInstruction(EInstruction instruction, CObject::Ptr arg1 = NULL) :
			mInstruction(instruction),
			mObjArg1(arg1),
			mProcessed(false)
		{

		}

		// Creators
		static CSokriptInstruction* return0Instruction();

		CSokriptInstruction::Ptr lastInstruction()
		{
			CSokriptInstruction* i = this;
			while (i->mNext) i = i->mNext;
			i->retain();
			return i;
		}

		void addInstruction(CSokriptInstruction::Ptr instruction)
		{
			lastInstruction()->mNext = instruction;
		}

		void addReturn0Instruction()
		{
			CSokriptInstruction* i = lastInstruction();
			if (i->mInstruction != eInstructionReturn)
			{
				i->mNext = return0Instruction();
			}
		}

		UInt32 length() const;
		UInt32 selfLength() const;

		UInt32 count() const
		{
			UInt32 result = 1;
			for (const CSokriptInstruction* i = this; i->mNext; ++result, i = i->mNext);
			return result;
		}

		CSokriptInstruction::Ptr instructionAtIndex(UInt32 index)
		{
			CSokriptInstruction* i = this;
			for (; i->mNext && index; --index, i = i->mNext);
			if (i) i->retain();
			return i;
		}

		static CSokriptInstruction::Ptr postProcessBytecode(CSokriptInstruction::Ptr instruction, std::list<CString>* arguments);
		static CSokriptInstruction::Ptr optimizeByteCode(CSokriptInstruction::Ptr instruction);
		static void dumpBytecodeToStream(const CSokriptInstruction* instruction, std::ostream& stream);

		void showAll(std::ostream& s, int i = 1) const;
		void show(std::ostream& s, int i = 1) const;

		virtual CString description() const;

		static const char* nameFromCode(EInstruction instruction);
	
	public:
		CSokriptInstruction::Ptr mNext;
		EInstruction mInstruction;
		CObject::Ptr mObjArg1;
		union  {
			SInt32 mSInt32Arg1;
			UInt16 mUInt16Arg1;
			UInt32 mUInt32Arg1;
		};

		union  {
			SInt32 mSInt32Arg2;
			UInt16 mUInt16Arg2;
			UInt32 mUInt32Arg2;
		};

		Bool mProcessed;
};

	} // namespace le
} // namespace sokira

#endif // not defined SL_LE_core_script_base_slCSokriptInstruction_hp
