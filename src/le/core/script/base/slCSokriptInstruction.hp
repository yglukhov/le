#if !defined SL_LE_core_script_base_slCSokriptInstruction_hp
#define SL_LE_core_script_base_slCSokriptInstruction_hp

#include <iosfwd>
#include <list>
#include <le/core/slTypes.h>
#include <le/core/slCObject.h>

#define _LE_FOR_INSTRUCTION_LIST(_OP_)	\
	_OP_(eInstructionPushVar)			\
	_OP_(eInstructionPushStr)			\
	_OP_(eInstructionPushInt)			\
	_OP_(eInstructionPushFloat)			\
	_OP_(eInstructionPushExternal)		\
	_OP_(eInstructionDiscard)			\
	_OP_(eInstructionAssign)			\
	_OP_(eInstructionAdd)				\
	_OP_(eInstructionSubstract)			\
	_OP_(eInstructionMultiply)			\
	_OP_(eInstructionDivide)			\
	_OP_(eInstructionNegate)			\
	_OP_(eInstructionEqual)				\
	_OP_(eInstructionNotEqual)			\
	_OP_(eInstructionGreaterThan)		\
	_OP_(eInstructionGreaterEqual)		\
	_OP_(eInstructionLessThan)			\
	_OP_(eInstructionLessEqual)			\
	_OP_(eInstructionNot)				\
	_OP_(eInstructionSetSymbolsCount)	\
	_OP_(eInstructionJump)				\
	_OP_(eInstructionJumpIfTrue)		\
	_OP_(eInstructionDeclareExternalSymbols)		\
	_OP_(eInstructionPushFunction)		\
	_OP_(eInstructionCall)				\
	_OP_(eInstructionReturn)

#define _LE_DECLARE_INSTRUCTION(instruction) instruction,

namespace sokira
{
	namespace le
	{

enum EInstruction
{
	eInstructionNOP = 0,
	_LE_FOR_INSTRUCTION_LIST(_LE_DECLARE_INSTRUCTION)
	eInstructionCount_			// This is not an instruction, just a constant indicating total instruction count
};


class CSokriptInstruction : public CObject
{
	LE_RTTI_BEGIN
		LE_RTTI_SELF(CSokriptInstruction)
		LE_RTTI_SINGLE_PUBLIC_PARENT
	LE_RTTI_END

	public:
		CSokriptInstruction() {}

		CSokriptInstruction(EInstruction instruction, CObject* arg1 = NULL) :
			mInstruction(instruction),
			mProcessed(false)
		{
			mObjArg1 = arg1;
		}

		CSokriptInstruction(EInstruction instruction, CObject::Ptr arg1) :
			mInstruction(instruction),
			mProcessed(false)
		{
			mObjArg1 = arg1.get();
			mObjArg1->retain();
		}

		~CSokriptInstruction();

		// Creators
		static CSokriptInstruction::Ptr createIfThenElse(CSokriptInstruction::Ptr expression,
														 CSokriptInstruction::Ptr ifPart,
														 CSokriptInstruction::Ptr elsePart);

		static CSokriptInstruction::Ptr createLoop(CSokriptInstruction::Ptr expression,
												   CSokriptInstruction::Ptr loopPart);

		static CSokriptInstruction* return0Instruction();

		CSokriptInstruction* lastInstruction()
		{
			CSokriptInstruction* i = this;
			while (i->mNext) i = i->mNext;
			return i;
		}

		void addInstruction(CSokriptInstruction::Ptr instruction)
		{
			lastInstruction()->mNext = instruction;
		}

		void addReturn0Instruction()
		{
			CSokriptInstruction* i = lastInstruction();
			if (i->mInstruction != eInstructionReturn)
			{
				i->mNext = return0Instruction();
			}
		}

		UInt32 length() const;
		UInt32 selfLength() const;

		static CSokriptInstruction::Ptr postProcessBytecode(CSokriptInstruction::Ptr instruction, std::list<CString>* arguments);
		static CSokriptInstruction::Ptr optimizeByteCode(CSokriptInstruction::Ptr instruction);
		static void dumpBytecodeToStream(const CSokriptInstruction* instruction, std::ostream& stream);

		void showAll(std::ostream& s, int i = 1) const;
		void show(std::ostream& s, int i = 1) const;

		virtual CString description() const;

	public:
		CSokriptInstruction::Ptr mNext;
		EInstruction mInstruction;
		union  {
			CObject* mObjArg1;
			SInt32 mSInt32Arg1;
			UInt16 mUInt16Arg1;
			UInt32 mUInt32Arg1;
		};

		union  {
			CObject* mObjArg2;
			SInt32 mSInt32Arg2;
			UInt16 mUInt16Arg2;
			UInt32 mUInt32Arg2;
		};

		Bool mProcessed;
};

	} // namespace le
} // namespace sokira

#endif // not defined SL_LE_core_script_base_slCSokriptInstruction_hp
