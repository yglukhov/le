#if !defined SL_LE_core_script_base_slCSokriptInstruction_hp
#define SL_LE_core_script_base_slCSokriptInstruction_hp

#include <iosfwd>
#include <list>
#include <le/core/slTypes.h>
#include <le/core/slCObject.h>

#define _LE_FOR_INSTRUCTION_LIST(_OP_)	\
	_OP_(eInstructionPushVar)			\
	_OP_(eInstructionPushStr)			\
	_OP_(eInstructionPushInt)			\
	_OP_(eInstructionPushFloat)			\
	_OP_(eInstructionDiscard)			\
	_OP_(eInstructionAssign)			\
	_OP_(eInstructionAdd)				\
	_OP_(eInstructionSubstract)			\
	_OP_(eInstructionMultiply)			\
	_OP_(eInstructionDivide)			\
	_OP_(eInstructionNegate)			\
	_OP_(eInstructionEqual)				\
	_OP_(eInstructionNotEqual)			\
	_OP_(eInstructionGreaterThan)		\
	_OP_(eInstructionGreaterEqual)		\
	_OP_(eInstructionLessThan)			\
	_OP_(eInstructionLessEqual)			\
	_OP_(eInstructionNot)				\
	_OP_(eInstructionSetSymbolsCount)	\
	_OP_(eInstructionJump)				\
	_OP_(eInstructionJumpIfTrue)		\
	_OP_(eInstructionStartFunction)		\
	_OP_(eInstructionDeclareExternalFunction)		\
	_OP_(eInstructionPushFunction)		\
	_OP_(eInstructionCall)				\
	_OP_(eInstructionCallExternal)		\
	_OP_(eInstructionReturn)

#define _LE_DECLARE_INSTRUCTION(instruction) instruction,

namespace sokira
{
	namespace le
	{

class CObject;

enum EInstruction
{
	eInstructionNOP = 0,
	_LE_FOR_INSTRUCTION_LIST(_LE_DECLARE_INSTRUCTION)
	eInstructionCount_			// This is not an instruction, just a constant indicating total instruction count
};


class CSokriptInstruction : public CObject
{
	LE_RTTI_BEGIN
		LE_RTTI_SELF(CSokriptInstruction)
		LE_RTTI_SINGLE_PUBLIC_PARENT
	LE_RTTI_END

	public:
		CSokriptInstruction() {}

		CSokriptInstruction(EInstruction instruction, CObject* arg1 = NULL) :
			mNext(NULL),
			mInstruction(instruction),
			mProcessed(false)
		{
			mObjArg1 = arg1;
		}

		CSokriptInstruction(EInstruction instruction, CObject::Ptr arg1) :
			mNext(NULL),
			mInstruction(instruction),
			mProcessed(false)
		{
			mObjArg1 = arg1.get();
			mObjArg1->retain();
		}

		~CSokriptInstruction();

		// Creators
		static CSokriptInstruction* createIfThenElse(CSokriptInstruction* expression,
													CSokriptInstruction* ifPart,
													 CSokriptInstruction* elsePart);

		static CSokriptInstruction* createLoop(CSokriptInstruction* expression,
											   CSokriptInstruction* loopPart);

		static CSokriptInstruction* createFunctionDefinition(char* name, std::list<CString>* args,
																	CSokriptInstruction* instruction);

		static CSokriptInstruction* return0Instruction();

		void addInstruction(CSokriptInstruction* instruction)
		{
			CSokriptInstruction* i = this;
			while (i->mNext) i = i->mNext;
			i->mNext = instruction;
		}

		void addInstruction(CSokriptInstruction::Ptr instruction)
		{
			instruction.retain();
			CSokriptInstruction* i = this;
			while (i->mNext) i = i->mNext;
			i->mNext = instruction;
		}

		void addReturn0Instruction()
		{
			CSokriptInstruction* i = this;
			while (i->mNext) i = i->mNext;
			if (i->mInstruction != eInstructionReturn)
			{
				i->mNext = return0Instruction();
			}
		}

		UInt32 length() const;
		UInt32 selfLength() const;

		static CSokriptInstruction::Ptr postProcessBytecode(CSokriptInstruction::Ptr instruction, std::list<CString>* arguments);
		static CSokriptInstruction::Ptr optimizeByteCode(CSokriptInstruction::Ptr instruction);
		static void dumpBytecodeToStream(const CSokriptInstruction* instruction, std::ostream& stream);

		void showAll(std::ostream& s, int i = 1) const;
		void show(std::ostream& s, int i = 1) const;

		virtual CString description() const;
	public:
		CSokriptInstruction* mNext;
		EInstruction mInstruction;
		union  {
			CObject* mObjArg1;
			SInt32 mSInt32Arg1;
			UInt16 mUInt16Arg1;
			UInt32 mUInt32Arg1;
		};

		union  {
			CObject* mObjArg2;
			SInt32 mSInt32Arg2;
			UInt16 mUInt16Arg2;
			UInt32 mUInt32Arg2;
		};

		Bool mProcessed;
};

	} // namespace le
} // namespace sokira

#endif // not defined SL_LE_core_script_base_slCSokriptInstruction_hp
