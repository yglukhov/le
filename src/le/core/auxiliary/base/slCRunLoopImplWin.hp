#if !defined SL_LE_core_auxiliary_base_slCRunloopImplWin_hp
#define SL_LE_core_auxiliary_base_slCRunloopImplWin_hp

#include <windows.h>

namespace sokira
{
	namespace le
	{

class CRunLoopImpl
{
	typedef std::map<UINT_PTR, TCFunction<> > TTimerFuncsMap;

	public:
		/// Start the run loop.
		void run()
		{
			MSG msg;
			BOOL result;

			while (result = GetMessage(&msg, NULL, 0, 0))
			{
				if (result == -1)
				{
					std::cout << "Run loop error: " << GetLastError() << std::endl;
				}
				else
				{
					//std::map<DWORD, std::string>::iterator it = messageNames.find(msg.message);
					//if (it != messageNames.end())
					//{
					//	std::cout << it->second << std::endl;
					//}
					//else
					//{
					//	std::cout << "Message: " << msg.message << std::endl;
					//}

					if (msg.message == WM_TIMER && msg.hwnd == NULL)
					{
						TTimerFuncsMap::iterator it = mTimerFuncs.find((UINT_PTR)msg.wParam);
						if (it != mTimerFuncs.end())
						{
							it->second();
						}
					}
					else
					{
						TranslateMessage(&msg);
						DispatchMessage(&msg);
					}
				}
			}
		}

		/// Stop the run loop.
		void stop()
		{
			PostQuitMessage(0);
		}

		static inline EEventType eventTypeFromMessage(UINT message)
		{
			switch (message)
			{
				case WM_LBUTTONDOWN:
				case WM_RBUTTONDOWN:
				case WM_MBUTTONDOWN:
					return eEventTypeMouseDown;

				case WM_LBUTTONUP:
				case WM_RBUTTONUP:
				case WM_MBUTTONUP:
					return eEventTypeMouseUp;

				case WM_MOUSEMOVE:
					return eEventTypeMouseMove;
			}

			return eEventTypeUnknown;
		}

		static inline EMouseButton mouseButtonForMessage(UINT message)
		{
			switch (message)
			{
				case WM_LBUTTONDOWN:
				case WM_LBUTTONUP:
					return eMouseButtonLeft;

				case WM_RBUTTONDOWN:
				case WM_RBUTTONUP:
					return eMouseButtonRight;

				case WM_MBUTTONDOWN:
				case WM_MBUTTONUP:
					return eMouseButtonMiddle;
			}

			return eMouseButtonUnknown;
		}

		/// Get next event. Can be used in a loop.
		/// @param mask some param
		CEvent nextEventMatchingMask(UInt32 mask)
		{
			MSG msg;
			BOOL result;
			CEvent event;

			while (result = GetMessage(&msg, NULL, 0, 0))
			{
				if (result == -1)
				{
					std::cout << "Run loop error: " << GetLastError() << std::endl;
				}
				else
				{
					//std::map<DWORD, std::string>::iterator it = messageNames.find(msg.message);
					//if (it != messageNames.end())
					//{
					//	std::cout << it->second << std::endl;
					//}
					//else
					//{
					//	std::cout << "Message: " << msg.message << std::endl;
					//}

					if (msg.message == WM_TIMER && msg.hwnd == NULL)
					{
						TTimerFuncsMap::iterator it = mTimerFuncs.find((UINT_PTR)msg.wParam);
						if (it != mTimerFuncs.end())
						{
							it->second();
						}
					}
					else
					{
						EEventType type = eventTypeFromMessage(msg.message);

						if (type & mask)
						{
							if (type & (eEventTypeMouseDown | eEventTypeMouseUp | eEventTypeMouseMove))
							{
								POINTS point = MAKEPOINTS(msg.lParam);
								event = CEvent(type, CPoint2D(point.x, point.y),(type == eEventTypeMouseDown) ? eButtonStateDown : ((type == eEventTypeMouseUp) ? eButtonStateUp : eButtonStateUnknown), mouseButtonForMessage(msg.message));
							}
							else if (type & (eEventTypeKeyDown | eEventTypeKeyUp))
							{
								event = CEvent(type, 0, (msg.message == WM_KEYDOWN) ? eButtonStateDown : eButtonStateUp);
							}
							
				
							break;
						}
						else
						{
							TranslateMessage(&msg);
							DispatchMessage(&msg);
						}
					}
				}
			}

			return event;
		}

		CTimer scheduledTimerWithInterval(UInt32 msInterval, TCFunction<> timerFunc)
		{
			UINT_PTR newTimer = SetTimer(NULL, NULL, msInterval, NULL);
			CTimer result;
			result.mTimerRef = (UInt64)newTimer;
			if (newTimer)
			{
				mTimerFuncs.insert(std::make_pair(newTimer, timerFunc));
			}
			else
			{
				std::cout << "Error: could not create timer" << std::endl;
			}
			return result;
		}

		private:
			TTimerFuncsMap mTimerFuncs;
};

	} // namespace le
} // namespace sokira

#endif // not defined SL_LE_core_auxiliary_base_slCRunloopImplWin_hp
