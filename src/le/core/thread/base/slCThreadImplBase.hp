#pragma once


#include <le/core/template/function/slTCFunction.h>
#include <le/core/auxiliary/slCRunLoop.h>
#include <le/core/slCString.h>

LE_NAMESPACE_START

class CThreadImplBase
{
	public:
		inline CThreadImplBase(const TCFunction<>& threadProc,
							   const CString& threadName) :
			mRunLoop(threadProc),
			mRefCount(1),
			mName(threadName)
		{

		}

		inline CThreadImplBase() :
			mRefCount(1),
			mName(LESTR("main"))
		{

		}

		virtual ~CThreadImplBase()
		{
			// Clear singletone map
			for (std::map<CString, std::pair<void*, void(*)(void*)> >::iterator it = mSingletones.begin(); it != mSingletones.end(); ++it)
			{
				(it->second.second)(it->second.first);
			}
		}

		// Overload this method to start CThreadImplBase::threadProc in a separate thread.
		virtual void start() = 0;

		inline void stop()
		{
			mRunLoop.stop();
		}

		virtual bool isRunning() const
		{
			return !mRunLoop.isStopped();
		}

		inline CString name() const
		{
			return mName;
		}

		inline CThreadImplBase* retain()
		{
			++mRefCount;
			return this;
		}

		inline void release()
		{
			--mRefCount;
			if (!mRefCount)
			{
				delete this;
			}
		}

		// The thread impl must call this proc
		inline static void threadProc(CThreadImplBase* impl)
		{
			impl->retain();
			try
			{
				impl->_threadProc();
			}
			catch(...)
			{
				// TODO: Complete correct error handling
			}
			impl->release();
		}

		void* singletone(const char* stdTypeName, void*(*creator)(), void (*deleter)(void*))
		{
			std::map<CString, std::pair<void*, void(*)(void*)> >::iterator it = mSingletones.find(stdTypeName);
			if (it == mSingletones.end())
			{
				mSingletones.insert(std::make_pair(CString(stdTypeName), std::make_pair(creator(), deleter)));
			}
			return mSingletones[stdTypeName].first;
		}

	private:

		inline void _threadProc()
		{
			mRunLoop.run();
		}

		UInt32 mRefCount;
		CRunLoop mRunLoop;
		CString mName;
		std::map<CString, std::pair<void*, void(*)(void*)> > mSingletones;
};

LE_NAMESPACE_END
