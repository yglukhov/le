#pragma once

#include <list>
#include <pthread.h>
#include "slCThreadImplBase.hp"

namespace sokira
{
	namespace le
	{

class CThreadImplPosix : public CThreadImplBase
{
	public:
		inline CThreadImplPosix(const TCFunction<>& threadProc,
								const CString& threadName) :
			CThreadImplBase(threadProc, threadName)
		{
			threadList().push_back(this);
		}

		inline CThreadImplPosix(pthread_t id) :
			mThreadID(id)
		{

		}

		~CThreadImplPosix()
		{
			for (std::list<CThreadImplPosix*>::iterator it = threadList().begin(); it != threadList().end(); ++it)
			{
				if (*it == this)
				{
					threadList().erase(it);
					return;
				}
			}
		}

		virtual void start();

		static CThreadImplBase* thread();

		static inline void sleep(UInt32 milliSeconds)
		{
			::sleep(milliSeconds);
		}

	protected:
		pthread_t mThreadID;

	private:
	
		static std::list<CThreadImplPosix*>& threadList()
		{
			static std::list<CThreadImplPosix*> mRegisteredThreads;
			return mRegisteredThreads;
		}

//		static std::list<CThreadImplPosix*> mRegisteredThreads;
};


typedef CThreadImplPosix CThreadImpl;
typedef pthread_t TThreadID;

	} // namespace le
} // namespace sokira
